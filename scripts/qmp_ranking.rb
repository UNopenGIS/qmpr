#!/usr/bin/env ruby
require 'json'
require 'time'
require 'csv'
require 'optparse'
require 'fileutils'

# QMP Ranking Generator
# Processes OpenStreetMap changesets with #qmp tag and generates rankings

class QMPRankingGenerator
  def initialize(options = {})
    @days_limit = options[:days] || 30
    @output_format = options[:format] || 'markdown'
    @output_file = options[:output]
    @cutoff_date = Time.now - (@days_limit * 24 * 60 * 60)
    @users = Hash.new(0)
    @total_changesets = 0
    @filtered_changesets = 0
  end

  def process_file(filename)
    puts "Processing changesets from #{filename}..."
    puts "Filtering changesets from the last #{@days_limit} days (after #{@cutoff_date.strftime('%Y-%m-%d')})"

    File.open(filename, 'r') do |file|
      file.each_line do |line|
        @total_changesets += 1
        process_changeset(JSON.parse(line.strip))
      end
    end

    puts "Processed #{@total_changesets} total changesets"
    puts "Found #{@filtered_changesets} QMP changesets in the last #{@days_limit} days"
    puts "Found #{@users.size} unique contributors"
  end

  private

  def process_changeset(changeset)
    # Check if changeset has #qmp tag in hashtags field or comment
    has_qmp_tag = false
    
    # First check hashtags field (preferred method)
    if changeset['hashtags']
      hashtags_value = changeset['hashtags']
      if hashtags_value.is_a?(Array)
        has_qmp_tag = hashtags_value.any? { |tag| tag.downcase == '#qmp' }
      elsif hashtags_value.is_a?(String)
        has_qmp_tag = hashtags_value.downcase.include?('#qmp')
      end
    end
    
    # Fallback: check comment field for #qmp tag
    unless has_qmp_tag
      comment = changeset['comment']
      has_qmp_tag = comment&.match?(/#qmp\b/i)
    end
    
    return unless has_qmp_tag

    # Check if changeset is within the time limit
    if changeset['created_at']
      created_at = Time.parse(changeset['created_at'])
      return if created_at < @cutoff_date
    end

    @filtered_changesets += 1
    user = changeset['user'] || 'unknown'
    changes = changeset['changes_count'] || changeset['num_changes'] || 0
    @users[user] += changes
  end

  public

  def generate_ranking
    @sorted_users = @users.sort_by { |_, size| -size }

    case @output_format
    when 'json'
      generate_json
    when 'csv'
      generate_csv
    when 'markdown'
      generate_markdown
    else
      puts "Unknown format: #{@output_format}"
      exit 1
    end
  end

  def get_planet_file_timestamp
    planet_file = 'data/changesets-latest.osm.bz2'
    if File.exist?(planet_file)
      File.mtime(planet_file).strftime('%Y-%m-%d %H:%M:%S UTC')
    else
      'Not available'
    end
  end

  private

  def generate_json
    output = {
      meta: {
        generated_at: Time.now.iso8601,
        days_filtered: @days_limit,
        total_contributors: @users.size,
        total_changesets: @filtered_changesets
      },
      ranking: @sorted_users.map.with_index do |(user, size), idx|
        {
          rank: idx + 1,
          user: user,
          changeset_size: size
        }
      end
    }

    output_content = JSON.pretty_generate(output)
    write_output(output_content, @output_file || 'qmp_ranking.json')
  end

  def generate_csv
    output_file = @output_file || 'qmp_ranking.csv'
    
    CSV.open(output_file, 'w') do |csv|
      csv << ['rank', 'user', 'changeset_size']
      @sorted_users.each_with_index do |(user, size), idx|
        csv << [idx + 1, user, size]
      end
    end

    puts "CSV ranking written to #{output_file} ğŸ“Š"
  end

  def generate_markdown
    output_file = @output_file || 'docs/index.md'
    now_str = Time.now.strftime('%Y-%m-%d %H:%M:%S UTC')
    planet_timestamp = get_planet_file_timestamp
    content = <<~MARKDOWN
      <!--
      âš ï¸ ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ã€‚æ‰‹å‹•ã§ç·¨é›†ã—ãªã„ã§ãã ã•ã„ã€‚
      DO NOT EDIT THIS FILE BY HAND. IT IS AUTO-GENERATED.
      -->

      # ğŸ… Quick Mapping Project Ranking / QMP ãƒ©ãƒ³ã‚­ãƒ³ã‚°

      **Generated on / ç”Ÿæˆæ—¥æ™‚:** #{now_str}  
      **Planet file timestamp / Planetãƒ•ã‚¡ã‚¤ãƒ«æ—¥æ™‚:** #{planet_timestamp}  
      **Period / å¯¾è±¡æœŸé–“:** Last #{@days_limit} days / éå»#{@days_limit}æ—¥é–“  
      **Total Contributors / ç·è²¢çŒ®è€…æ•°:** #{@users.size}  
      **Total QMP Changesets / ç·QMPãƒã‚§ãƒ³ã‚¸ã‚»ãƒƒãƒˆæ•°:** #{@filtered_changesets}

      | Rank / é †ä½ | User / ãƒ¦ãƒ¼ã‚¶ãƒ¼ | Changeset Size (Objects) / ãƒã‚§ãƒ³ã‚¸ã‚»ãƒƒãƒˆã‚µã‚¤ã‚ºï¼ˆç·¨é›†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°ï¼‰ |
      |------|------|----------------|
    MARKDOWN

    @sorted_users.each_with_index do |(user, size), idx|
      content += "| #{idx + 1} | #{user} | #{size} |\n"
    end

    content += <<~MARKDOWN

      ---

      **Note / æ³¨æ„:**  
      The "Changeset Size" column shows the total number of edited objects (nodes, ways, relations) per user.  
      ã€Œãƒã‚§ãƒ³ã‚¸ã‚»ãƒƒãƒˆã‚µã‚¤ã‚ºã€ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã®ç·¨é›†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°ï¼ˆãƒãƒ¼ãƒ‰ãƒ»ã‚¦ã‚§ã‚¤ãƒ»ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆè¨ˆï¼‰ã§ã™ã€‚

      This ranking is automatically generated from [planet/changesets-latest.osm.bz2](https://planet.openstreetmap.org/planet/changesets-latest.osm.bz2) using local Ruby scripts.  
      ã“ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã¯ [planet/changesets-latest.osm.bz2](https://planet.openstreetmap.org/planet/changesets-latest.osm.bz2) ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§Rubyã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ã‚ˆã‚ŠæŠ½å‡ºã—ã€å®šæœŸçš„ã«è‡ªå‹•ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ã€‚

      - Operation is recommended as a cron job on Raspberry Pi or Linux server.  
        é‹ç”¨ã¯Raspberry Piã‚„Linuxã‚µãƒ¼ãƒãƒ¼ã§ã®cronã‚¸ãƒ§ãƒ–å®Ÿè¡Œã‚’æ¨å¥¨
      - All processing is local and Ruby-based.  
        ã™ã¹ã¦ãƒ­ãƒ¼ã‚«ãƒ«å‡¦ç†ãƒ»Rubyãƒ™ãƒ¼ã‚¹
      - GitHub Actions and CI/CD automation are not supported.  
        GitHub Actionsã‚„CI/CDã«ã‚ˆã‚‹è‡ªå‹•åŒ–ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¾ã›ã‚“

      ---

      *This ranking is automatically generated from OpenStreetMap changesets containing the #qmp tag.*  
      *ã“ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã¯#qmpã‚¿ã‚°ã‚’å«ã‚€OpenStreetMapãƒã‚§ãƒ³ã‚¸ã‚»ãƒƒãƒˆã‹ã‚‰è‡ªå‹•ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã™ã€‚*

      *Data collected locally from [planet/changesets-latest.osm.bz2](https://planet.openstreetmap.org/planet/changesets-latest.osm.bz2) using Ruby scripts.*  
      *ãƒ‡ãƒ¼ã‚¿ã¯planetãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã§Rubyã‚¹ã‚¯ãƒªãƒ—ãƒˆã«ã‚ˆã‚ŠæŠ½å‡ºã—ã¦ã„ã¾ã™*

      ## About QMP / QMPã«ã¤ã„ã¦

      **English:**  
      The Quick Mapping Project (#qmp) encourages rapid, collaborative mapping contributions to OpenStreetMap.  
      Join the community and contribute to make our map data better!

      **æ—¥æœ¬èª:**  
      Quick Mapping Projectï¼ˆ#qmpï¼‰ã¯ã€OpenStreetMapã¸ã®è¿…é€Ÿã§å”åŠ›çš„ãªãƒãƒƒãƒ”ãƒ³ã‚°è²¢çŒ®ã‚’å¥¨åŠ±ã—ã¾ã™ã€‚  
      ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã«å‚åŠ ã—ã¦ã€ã‚ˆã‚Šè‰¯ã„åœ°å›³ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆã«è²¢çŒ®ã—ã¾ã—ã‚‡ã†ï¼

      **Last updated / æœ€çµ‚æ›´æ–°:** #{now_str}
    MARKDOWN

    write_output(content, output_file)
  end

  def write_output(content, filename)
    # Ensure directory exists
    dir = File.dirname(filename)
    FileUtils.mkdir_p(dir) unless Dir.exist?(dir)

    File.write(filename, content)
    puts "Ranking written to #{filename} ğŸ‰"
  end
end

# Command line interface
if __FILE__ == $0
  options = {}
  
  OptionParser.new do |opts|
    opts.banner = "Usage: #{$0} [options] input_file"
    
    opts.on("-d", "--days DAYS", Integer, "Filter changesets from last N days (default: 30)") do |d|
      options[:days] = d
    end
    
    opts.on("-f", "--format FORMAT", String, "Output format: markdown, json, csv (default: markdown)") do |f|
      options[:format] = f
    end
    
    opts.on("-o", "--output FILE", String, "Output file path") do |o|
      options[:output] = o
    end
    
    opts.on("-h", "--help", "Show this help") do
      puts opts
      exit
    end
  end.parse!

  if ARGV.empty?
    puts "Error: Please provide an input file"
    puts "Usage: #{$0} [options] input_file"
    exit 1
  end

  input_file = ARGV[0]
  unless File.exist?(input_file)
    puts "Error: Input file '#{input_file}' not found"
    exit 1
  end

  generator = QMPRankingGenerator.new(options)
  generator.process_file(input_file)
  generator.generate_ranking
end
